defmodule OnTheMap.Crypto.Identity do
  @moduledoc """
  OnTheMap.Crypto.Identity provides Ecto schema for the OnTheMap's authenticaiton protocol.
  """
  use Ecto.Schema
  import Ecto.Changeset

  alias OnTheMap.Crypto

  alias Uptight.Base, as: B
  alias Uptight.Text, as: T

  @typedoc """
  Identity.t() is generated by a macro. This is why we can't use it in the type definition.
  So we abuse the fact that structs are maps, and use a map type instead.
  `st` stands for "static type".
  """
  @type st :: %{required(:__struct__) => OnTheMap.Crypto.Identity, optional(any()) => any()}

  schema "crypto_identities" do
    # Urlsafe base64 encoded public key
    field :pk, :string
    # FQDN of the user's website
    field :url, :string
    # Current challenge for the identity
    field :challenge, :string

    timestamps()
  end

  @spec tighten(st()) :: st()
  def tighten(identity) do
    # We use map update syntax to update pk with urlsafe base64 encoding using Uptight.Base.
    # We make url field into an Uptight.Text.
    # Finally, we do the same with challenge.
    identity
    |> Map.update!(:pk, &B.mk_url!/1)
    |> Map.update!(:url, &T.new!/1)
    |> Map.update!(:challenge, &T.new!/1)
  end

  @doc """
  This is an Ecto changeset, which is a tool to validate and cast data before it is inserted into the database.
  Data validation in Ecto means that we can ensure that the data we receive *from the user* is in the correct format.
  Casting is the process of converting user input into a format that the database can understand.

  This particular changeset is for the creation of a new identity.
  The first argument is the changeset, which is a map of the current data for the identity.
  You can think of it as of a sink where the data is poured in.
  The second argument is the data from the form (or another user input source), which is a map of the data the user submitted.
  You can think of it as of a bucket of water that is poured into the sink.
  """
  @spec changeset(st(), map()) :: Ecto.Changeset.t()
  def changeset(identity, attrs) do
    identity
    # The `cast/3` function takes the changeset and the data from the input source and casts the data into the changeset.
    |> cast(attrs, [:url, :pk])
    # The `validate_required/2` function takes the changeset and a list of fields that are required.
    |> validate_required([:url, :pk])
    # The `ensure_valid_pk/1` function takes the changeset and checks if the given public key is URL-safe base64 encoded.
    |> ensure_valid_pk()
    # The `unique_constraint/2` function takes the changeset and a list of fields that should be unique. That's required because we use keyword lists.
    |> unique_constraint(:pk)
  end

  @spec challenge_changeset(st(), map()) :: Ecto.Changeset.t()
  def challenge_changeset(identity, attrs) do
    identity
    |> cast(attrs, [:challenge])
    |> validate_required(:challenge)
  end

  # Write a private changeset validation function that checks if the given string is URL-safe base64 encoded.
  # If it is not, add an error to the changeset!
  defp ensure_valid_pk(changeset) do
    pk = fetch_field!(changeset, :pk)

    if Crypto.valid_pk?(pk), do: changeset, else: add_error(changeset, :pk, "invalid public key")
  end
end
